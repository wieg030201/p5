// Previos practica 5

// Cuando acondicionamos el sensor se conectará al microcontrolador a un pin analógico.

#include <>
#include "config.h"
#include "timer.h" // Funcion creada para inicializar timer en la sesión anterior (inicializarTimer1).

// Declaracion de funciones
unsigned int interpolarSensor(unsigned int medida_adc);

// Declaracion de variables
static int muestra=0;
static int medidadigital;


int main (void){
inicializarReloj();

//Pines analogicos o digitales
// Puerto RB14 digital (LED) -> 1.
AD1PCFGL|=(1<<14);
// Conectamos el sensor al puerto RA1 AN1 (analogico) -> 0.
AD1PCFGL&=~(1<<1);

//Salidas y Entradas.

// Salida el LED RB14.
TRISB&=~(1<<14);
//Entrada datos del sensor.
TRISA|=(1<<1);
//LED apagado inicialmente
PORTB|=(1<<14); // LED en pull-up. apagado ->1 


// Configuramos timer y empezamos a contar, como tenemos que tomar 
inicializarTimer1(1000); //100 ms

// Configuracion AD1
AD1CON3=0x0105; // 1 numero de ciclos de muestreo, 5 Preescalado calculado como tiempo total= 1/500000= 2microseg; 13*TAD=2microseg; TAD=150ns=6*25ns=(1+5)*25ns.
IFS0bits.AD1IF=0; // Bandera a cero.
IEC0bits.AD1IE=1; // Habilitamos interrupcion al concluir la conversion.
IPC3bits.AD1IP=4; // Prioridad intermedia.
AD1CHS0=1; // Seleccionamos el canal.
AD1CON1=0x80E0; // Arrancamos periférico pero no empieza muestrear y comienza la conversión automáticamente al terminar de muestrear.
AD1CON1|=(1<<15);//Empezamos a muestrear.

while(1){
int valor;
valor=interpolarSensor(medidadigital);

if(valor>=600){ //Ponemos el umbral en 600 luxes
PORTB|=(1<<14); // LED apagado si esta por encima del umbral.

}
else{
PORTB&=~(1<<14); Encendemos LED cuando está por debajo del umbral. -> 0 (pull-up)


}
}
return 0;
}

void __attribute__((interrupt,no_auto_psv))
_T1Interrupt(void){ //Función interrupción Timer 1
IFS0bits.T1IF=0; // Bandera a 0.
muestra=1; // Muestra adquiere el valor 1 indicando que han pasado 100 ms y se puede adquirir medida.
}

void __attribute__((interrupt,no_auto_psv)) _ADC1Interrupt(void){ //Función interrupción AD1 cuando termina una conversión.
IFS0bits.AD1IF=0;

if(muestra==1){//Si han pasado 100 ms, se tomará una medida.
// El sensor irá de 0,5 (0 lx) a 3 voltios (1000 lx) y saturará aproximadamente en 3,3 (un poco antes al ser rail to rail) -> Cuando fotorresistencia valga 1589,28 ohmios con R1=10 Kohmios R2=1,8 Kohmios y R3=8,9 kohmios
medidadigital=ACD1BUF0;

}

AD1CON1|=(1<<15);//Vuelve a empezar a muestrear.

}

unsigned int interpolarSensor(unsigned int medida_adc){ //Función para realizar una interpolación lineal de los valores adquiridos del sensor. Medida_adc es en voltios digitales.
// Vectores consatantes con la información necesaria para interpolar.

const unsigned int vec_adc[]={155, 384, 484, 631, 701, 738, 795, 879, 924, 964 }; // Voltios digitales a partir de la curva de calibracion realizada en la sesión 1 de la práctica 5. Nuestros cálculos nos han requerido una R3 de 8900 ohmios. En el laboratorio no se ha encontrado de ese valor por lo que hemos puesto dos resistencias en serie de 680 ohmios y 8200 ohmios=8880 ohmios. Se realizará el cálculo con este valor para mayor precisión.
const unsigned int vec_lux[]={0, 105, 200, 390, 500, 600, 700, 850, 1000, 1200}; // Valor de los luxes.

//Variable para el bucle for
int i;
unsigned int lux; // Valor que será devuelto por la función

//Bucle for para hacer la interpolación de la medida.
for(i=0;i<10;i++){
if(vec_adc[i]<medidadigital && medidadigital<vec_adc[i+1]){

lux=((vec_lux[i+1]-vec_lux[i])/(vec_adc[i+1]-vec_adc[i]))*(medidadigital-vec_adc[i])+vec_lux[i];

}

}
return (lux);
}


